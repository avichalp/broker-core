// Code generated by sqlc. DO NOT EDIT.
// source: auction_deal.sql

package db

import (
	"context"
	"time"

	"github.com/textileio/bidbot/lib/auction"
	"github.com/textileio/broker-core/broker"
)

const createAuctionDeal = `-- name: CreateAuctionDeal :exec
INSERT INTO auction_deals(
id,
auction_data_id,
batch_id,
storage_provider_id,
price_per_gib_per_epoch,
start_epoch,
verified,
fast_retrieval,
auction_id,
bid_id,
status,
executing,
error_cause,
retries,
proposal_cid,
deal_id,
deal_expiration,
deal_market_status,
ready_at
    ) VALUES(
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8,
      $9,
      $10,
      $11,
      $12,
      $13,
      $14,
      $15,
      $16,
      $17,
      $18,
      $19
      )
`

type CreateAuctionDealParams struct {
	ID                  string         `json:"id"`
	AuctionDataID       string         `json:"auctionDataID"`
	BatchID             broker.BatchID `json:"batchID"`
	StorageProviderID   string         `json:"storageProviderID"`
	PricePerGibPerEpoch int64          `json:"pricePerGibPerEpoch"`
	StartEpoch          uint64         `json:"startEpoch"`
	Verified            bool           `json:"verified"`
	FastRetrieval       bool           `json:"fastRetrieval"`
	AuctionID           auction.ID     `json:"auctionID"`
	BidID               auction.BidID  `json:"bidID"`
	Status              Status         `json:"status"`
	Executing           bool           `json:"executing"`
	ErrorCause          string         `json:"errorCause"`
	Retries             int            `json:"retries"`
	ProposalCid         string         `json:"proposalCid"`
	DealID              int64          `json:"dealID"`
	DealExpiration      uint64         `json:"dealExpiration"`
	DealMarketStatus    uint64         `json:"dealMarketStatus"`
	ReadyAt             time.Time      `json:"readyAt"`
}

func (q *Queries) CreateAuctionDeal(ctx context.Context, arg CreateAuctionDealParams) error {
	_, err := q.exec(ctx, q.createAuctionDealStmt, createAuctionDeal,
		arg.ID,
		arg.AuctionDataID,
		arg.BatchID,
		arg.StorageProviderID,
		arg.PricePerGibPerEpoch,
		arg.StartEpoch,
		arg.Verified,
		arg.FastRetrieval,
		arg.AuctionID,
		arg.BidID,
		arg.Status,
		arg.Executing,
		arg.ErrorCause,
		arg.Retries,
		arg.ProposalCid,
		arg.DealID,
		arg.DealExpiration,
		arg.DealMarketStatus,
		arg.ReadyAt,
	)
	return err
}

const getAuctionDeal = `-- name: GetAuctionDeal :one
SELECT id, auction_data_id, storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at, batch_id FROM auction_deals WHERE id = $1
`

func (q *Queries) GetAuctionDeal(ctx context.Context, id string) (AuctionDeal, error) {
	row := q.queryRow(ctx, q.getAuctionDealStmt, getAuctionDeal, id)
	var i AuctionDeal
	err := row.Scan(
		&i.ID,
		&i.AuctionDataID,
		&i.StorageProviderID,
		&i.PricePerGibPerEpoch,
		&i.StartEpoch,
		&i.Verified,
		&i.FastRetrieval,
		&i.AuctionID,
		&i.BidID,
		&i.Status,
		&i.Executing,
		&i.ErrorCause,
		&i.Retries,
		&i.ProposalCid,
		&i.DealID,
		&i.DealExpiration,
		&i.DealMarketStatus,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BatchID,
	)
	return i, err
}

const getAuctionDealIDs = `-- name: GetAuctionDealIDs :many
SELECT id FROM auction_deals WHERE auction_data_id = $1
`

func (q *Queries) GetAuctionDealIDs(ctx context.Context, auctionDataID string) ([]string, error) {
	rows, err := q.query(ctx, q.getAuctionDealIDsStmt, getAuctionDealIDs, auctionDataID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuctionDealsByStatus = `-- name: GetAuctionDealsByStatus :many
SELECT id, auction_data_id, storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at, batch_id FROM auction_deals WHERE status = $1
`

func (q *Queries) GetAuctionDealsByStatus(ctx context.Context, status Status) ([]AuctionDeal, error) {
	rows, err := q.query(ctx, q.getAuctionDealsByStatusStmt, getAuctionDealsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AuctionDeal
	for rows.Next() {
		var i AuctionDeal
		if err := rows.Scan(
			&i.ID,
			&i.AuctionDataID,
			&i.StorageProviderID,
			&i.PricePerGibPerEpoch,
			&i.StartEpoch,
			&i.Verified,
			&i.FastRetrieval,
			&i.AuctionID,
			&i.BidID,
			&i.Status,
			&i.Executing,
			&i.ErrorCause,
			&i.Retries,
			&i.ProposalCid,
			&i.DealID,
			&i.DealExpiration,
			&i.DealMarketStatus,
			&i.ReadyAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.BatchID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextPendingAuctionDeal = `-- name: NextPendingAuctionDeal :one
UPDATE auction_deals
SET executing = TRUE,
    updated_at = CURRENT_TIMESTAMP
WHERE id = (SELECT id FROM auction_deals
    WHERE auction_deals.status = $1 AND
          (
            (auction_deals.ready_at < CURRENT_TIMESTAMP AND NOT auction_deals.executing) OR
            (auction_deals.executing AND extract(epoch from current_timestamp - auction_deals.updated_at) > $2::bigint)
   	  )
    ORDER BY auction_deals.ready_at asc
    FOR UPDATE SKIP LOCKED
    LIMIT 1)
RETURNING id, auction_data_id, storage_provider_id, price_per_gib_per_epoch, start_epoch, verified, fast_retrieval, auction_id, bid_id, status, executing, error_cause, retries, proposal_cid, deal_id, deal_expiration, deal_market_status, ready_at, created_at, updated_at, batch_id
`

type NextPendingAuctionDealParams struct {
	Status       Status `json:"status"`
	StuckSeconds int64  `json:"stuckSeconds"`
}

func (q *Queries) NextPendingAuctionDeal(ctx context.Context, arg NextPendingAuctionDealParams) (AuctionDeal, error) {
	row := q.queryRow(ctx, q.nextPendingAuctionDealStmt, nextPendingAuctionDeal, arg.Status, arg.StuckSeconds)
	var i AuctionDeal
	err := row.Scan(
		&i.ID,
		&i.AuctionDataID,
		&i.StorageProviderID,
		&i.PricePerGibPerEpoch,
		&i.StartEpoch,
		&i.Verified,
		&i.FastRetrieval,
		&i.AuctionID,
		&i.BidID,
		&i.Status,
		&i.Executing,
		&i.ErrorCause,
		&i.Retries,
		&i.ProposalCid,
		&i.DealID,
		&i.DealExpiration,
		&i.DealMarketStatus,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.BatchID,
	)
	return i, err
}

const updateAuctionDeal = `-- name: UpdateAuctionDeal :execrows
UPDATE auction_deals
SET 
    auction_data_id = $1,
    batch_id = $2,
    storage_provider_id = $3,
    price_per_gib_per_epoch = $4,
    start_epoch = $5,
    verified = $6,
    fast_retrieval = $7,
    auction_id = $8,
    bid_id = $9,
    status = $10,
    executing = $11,
    error_cause = $12,
    retries = $13,
    proposal_cid = $14,
    deal_id = $15,
    deal_expiration = $16,
    deal_market_status = $17,
    ready_at = $18,
    updated_at = CURRENT_TIMESTAMP
    WHERE id = $19
`

type UpdateAuctionDealParams struct {
	AuctionDataID       string         `json:"auctionDataID"`
	BatchID             broker.BatchID `json:"batchID"`
	StorageProviderID   string         `json:"storageProviderID"`
	PricePerGibPerEpoch int64          `json:"pricePerGibPerEpoch"`
	StartEpoch          uint64         `json:"startEpoch"`
	Verified            bool           `json:"verified"`
	FastRetrieval       bool           `json:"fastRetrieval"`
	AuctionID           auction.ID     `json:"auctionID"`
	BidID               auction.BidID  `json:"bidID"`
	Status              Status         `json:"status"`
	Executing           bool           `json:"executing"`
	ErrorCause          string         `json:"errorCause"`
	Retries             int            `json:"retries"`
	ProposalCid         string         `json:"proposalCid"`
	DealID              int64          `json:"dealID"`
	DealExpiration      uint64         `json:"dealExpiration"`
	DealMarketStatus    uint64         `json:"dealMarketStatus"`
	ReadyAt             time.Time      `json:"readyAt"`
	ID                  string         `json:"id"`
}

func (q *Queries) UpdateAuctionDeal(ctx context.Context, arg UpdateAuctionDealParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAuctionDealStmt, updateAuctionDeal,
		arg.AuctionDataID,
		arg.BatchID,
		arg.StorageProviderID,
		arg.PricePerGibPerEpoch,
		arg.StartEpoch,
		arg.Verified,
		arg.FastRetrieval,
		arg.AuctionID,
		arg.BidID,
		arg.Status,
		arg.Executing,
		arg.ErrorCause,
		arg.Retries,
		arg.ProposalCid,
		arg.DealID,
		arg.DealExpiration,
		arg.DealMarketStatus,
		arg.ReadyAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
