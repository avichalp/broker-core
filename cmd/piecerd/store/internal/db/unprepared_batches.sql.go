// Code generated by sqlc. DO NOT EDIT.
// source: unprepared_batches.sql

package db

import (
	"context"
)

const createUnpreparedBatch = `-- name: CreateUnpreparedBatch :exec
INSERT INTO unprepared_batches(
    storage_deal_id,
    status,
    data_cid
 ) VALUES ($1, $2, $3)
`

type CreateUnpreparedBatchParams struct {
	StorageDealID string `json:"storageDealID"`
	Status        int16  `json:"status"`
	DataCid       string `json:"dataCid"`
}

func (q *Queries) CreateUnpreparedBatch(ctx context.Context, arg CreateUnpreparedBatchParams) error {
	_, err := q.exec(ctx, q.createUnpreparedBatchStmt, createUnpreparedBatch, arg.StorageDealID, arg.Status, arg.DataCid)
	return err
}

const deleteUnpreparedBatch = `-- name: DeleteUnpreparedBatch :exec
DELETE FROM unprepared_batches 
WHERE storage_deal_id = $1 AND 
      status = 2
`

func (q *Queries) DeleteUnpreparedBatch(ctx context.Context, storageDealID string) error {
	_, err := q.exec(ctx, q.deleteUnpreparedBatchStmt, deleteUnpreparedBatch, storageDealID)
	return err
}

const getNextPending = `-- name: GetNextPending :one
UPDATE unprepared_batches
SET status = 2, updated_at = CURRENT_TIMESTAMP
WHERE storage_deal_id = (SELECT id FROM unprepared_batches ub
            WHERE ub.ready_at < CURRENT_TIMESTAMP AND
                  ub.status = 1  
                  ORDER BY ub.ready_at asc 
                  FOR UPDATE SKIP LOCKED
                  LIMIT 1)
RETURNING storage_deal_id, status, data_cid, ready_at, created_at, updated_at
`

func (q *Queries) GetNextPending(ctx context.Context) (UnpreparedBatch, error) {
	row := q.queryRow(ctx, q.getNextPendingStmt, getNextPending)
	var i UnpreparedBatch
	err := row.Scan(
		&i.StorageDealID,
		&i.Status,
		&i.DataCid,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
