// Code generated by sqlc. DO NOT EDIT.
// source: unprepared_batches.sql

package db

import (
	"context"
	"time"

	"github.com/textileio/broker-core/broker"
)

const createUnpreparedBatch = `-- name: CreateUnpreparedBatch :exec
INSERT INTO unprepared_batches(
    storage_deal_id,
    status,
    data_cid
 ) VALUES ($1, $2, $3)
`

type CreateUnpreparedBatchParams struct {
	StorageDealID broker.StorageDealID `json:"storageDealID"`
	Status        int16                `json:"status"`
	DataCid       string               `json:"dataCid"`
}

func (q *Queries) CreateUnpreparedBatch(ctx context.Context, arg CreateUnpreparedBatchParams) error {
	_, err := q.exec(ctx, q.createUnpreparedBatchStmt, createUnpreparedBatch, arg.StorageDealID, arg.Status, arg.DataCid)
	return err
}

const deleteUnpreparedBatch = `-- name: DeleteUnpreparedBatch :execrows
DELETE FROM unprepared_batches 
WHERE storage_deal_id = $1 AND 
      status = 2
`

func (q *Queries) DeleteUnpreparedBatch(ctx context.Context, storageDealID broker.StorageDealID) (int64, error) {
	result, err := q.exec(ctx, q.deleteUnpreparedBatchStmt, deleteUnpreparedBatch, storageDealID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getNextPending = `-- name: GetNextPending :one
UPDATE unprepared_batches
SET status = 2, updated_at = CURRENT_TIMESTAMP
WHERE storage_deal_id = (SELECT ub.storage_deal_id FROM unprepared_batches ub
            WHERE ub.ready_at < CURRENT_TIMESTAMP AND
                  ub.status = 1  
                  ORDER BY ub.ready_at asc 
                  FOR UPDATE SKIP LOCKED
                  LIMIT 1)
RETURNING storage_deal_id, status, data_cid, ready_at, created_at, updated_at
`

func (q *Queries) GetNextPending(ctx context.Context) (UnpreparedBatch, error) {
	row := q.queryRow(ctx, q.getNextPendingStmt, getNextPending)
	var i UnpreparedBatch
	err := row.Scan(
		&i.StorageDealID,
		&i.Status,
		&i.DataCid,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const moveToPending = `-- name: MoveToPending :execrows
UPDATE unprepared_batches 
SET status = 1, updated_at = CURRENT_TIMESTAMP, ready_at=$2
WHERE storage_deal_id = $1 AND 
      status = 2
`

type MoveToPendingParams struct {
	StorageDealID broker.StorageDealID `json:"storageDealID"`
	ReadyAt       time.Time            `json:"readyAt"`
}

func (q *Queries) MoveToPending(ctx context.Context, arg MoveToPendingParams) (int64, error) {
	result, err := q.exec(ctx, q.moveToPendingStmt, moveToPending, arg.StorageDealID, arg.ReadyAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
