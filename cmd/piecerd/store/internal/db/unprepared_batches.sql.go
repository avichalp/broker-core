// Code generated by sqlc. DO NOT EDIT.
// source: unprepared_batches.sql

package db

import (
	"context"
	"time"

	"github.com/textileio/broker-core/broker"
)

const createUnpreparedBatch = `-- name: CreateUnpreparedBatch :exec
INSERT INTO unprepared_batches(
    batch_id,
    data_cid
 ) VALUES ($1, $2)
`

type CreateUnpreparedBatchParams struct {
	BatchID broker.BatchID `json:"batchID"`
	DataCid string         `json:"dataCid"`
}

func (q *Queries) CreateUnpreparedBatch(ctx context.Context, arg CreateUnpreparedBatchParams) error {
	_, err := q.exec(ctx, q.createUnpreparedBatchStmt, createUnpreparedBatch, arg.BatchID, arg.DataCid)
	return err
}

const getNextPending = `-- name: GetNextPending :one
UPDATE unprepared_batches
SET status = 'executing', updated_at = CURRENT_TIMESTAMP
WHERE batch_id = (SELECT ub.batch_id FROM unprepared_batches ub
            WHERE (ub.ready_at < CURRENT_TIMESTAMP AND ub.status = 'pending') OR
	          (ub.status='executing' and extract(epoch from current_timestamp - ub.updated_at) > $1::bigint)
                  ORDER BY ub.ready_at asc 
                  FOR UPDATE SKIP LOCKED
                  LIMIT 1)
RETURNING batch_id, status, data_cid, ready_at, created_at, updated_at
`

func (q *Queries) GetNextPending(ctx context.Context, stuckseconds int64) (UnpreparedBatch, error) {
	row := q.queryRow(ctx, q.getNextPendingStmt, getNextPending, stuckseconds)
	var i UnpreparedBatch
	err := row.Scan(
		&i.BatchID,
		&i.Status,
		&i.DataCid,
		&i.ReadyAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const moveToStatus = `-- name: MoveToStatus :execrows
UPDATE unprepared_batches 
SET status = $3, updated_at = CURRENT_TIMESTAMP, ready_at=$2
WHERE batch_id = $1
`

type MoveToStatusParams struct {
	BatchID broker.BatchID        `json:"batchID"`
	ReadyAt time.Time             `json:"readyAt"`
	Status  UnpreparedBatchStatus `json:"status"`
}

func (q *Queries) MoveToStatus(ctx context.Context, arg MoveToStatusParams) (int64, error) {
	result, err := q.exec(ctx, q.moveToStatusStmt, moveToStatus, arg.BatchID, arg.ReadyAt, arg.Status)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
