// Code generated by sqlc. DO NOT EDIT.
// source: bid.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/textileio/bidbot/lib/auction"
)

const createBid = `-- name: CreateBid :exec
INSERT INTO bids(
    id,
    auction_id,
    wallet_addr_sig,
    storage_provider_id,
    bidder_id,
    ask_price,
    verified_ask_price,
    start_epoch,
    fast_retrieval,
    received_at
    ) VALUES (
      $1,
      $2,
      $3,
      $4,
      $5,
      $6,
      $7,
      $8,
      $9,
      $10)
`

type CreateBidParams struct {
	ID                auction.BidID `json:"id"`
	AuctionID         auction.ID    `json:"auctionID"`
	WalletAddrSig     []byte        `json:"walletAddrSig"`
	StorageProviderID string        `json:"storageProviderID"`
	BidderID          string        `json:"bidderID"`
	AskPrice          int64         `json:"askPrice"`
	VerifiedAskPrice  int64         `json:"verifiedAskPrice"`
	StartEpoch        int64         `json:"startEpoch"`
	FastRetrieval     bool          `json:"fastRetrieval"`
	ReceivedAt        time.Time     `json:"receivedAt"`
}

func (q *Queries) CreateBid(ctx context.Context, arg CreateBidParams) error {
	_, err := q.exec(ctx, q.createBidStmt, createBid,
		arg.ID,
		arg.AuctionID,
		arg.WalletAddrSig,
		arg.StorageProviderID,
		arg.BidderID,
		arg.AskPrice,
		arg.VerifiedAskPrice,
		arg.StartEpoch,
		arg.FastRetrieval,
		arg.ReceivedAt,
	)
	return err
}

const getAuctionBids = `-- name: GetAuctionBids :many
SELECT id, auction_id, wallet_addr_sig, storage_provider_id, bidder_id, ask_price, verified_ask_price, start_epoch, fast_retrieval, received_at, won_at, proposal_cid, proposal_cid_delivered_at, proposal_cid_delivery_error FROM bids
WHERE auction_id = $1
`

func (q *Queries) GetAuctionBids(ctx context.Context, auctionID auction.ID) ([]Bid, error) {
	rows, err := q.query(ctx, q.getAuctionBidsStmt, getAuctionBids, auctionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bid
	for rows.Next() {
		var i Bid
		if err := rows.Scan(
			&i.ID,
			&i.AuctionID,
			&i.WalletAddrSig,
			&i.StorageProviderID,
			&i.BidderID,
			&i.AskPrice,
			&i.VerifiedAskPrice,
			&i.StartEpoch,
			&i.FastRetrieval,
			&i.ReceivedAt,
			&i.WonAt,
			&i.ProposalCid,
			&i.ProposalCidDeliveredAt,
			&i.ProposalCidDeliveryError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuctionWinningBids = `-- name: GetAuctionWinningBids :many
SELECT id, auction_id, wallet_addr_sig, storage_provider_id, bidder_id, ask_price, verified_ask_price, start_epoch, fast_retrieval, received_at, won_at, proposal_cid, proposal_cid_delivered_at, proposal_cid_delivery_error FROM bids
WHERE auction_id = $1 and won_at IS NOT NULL
`

func (q *Queries) GetAuctionWinningBids(ctx context.Context, auctionID auction.ID) ([]Bid, error) {
	rows, err := q.query(ctx, q.getAuctionWinningBidsStmt, getAuctionWinningBids, auctionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bid
	for rows.Next() {
		var i Bid
		if err := rows.Scan(
			&i.ID,
			&i.AuctionID,
			&i.WalletAddrSig,
			&i.StorageProviderID,
			&i.BidderID,
			&i.AskPrice,
			&i.VerifiedAskPrice,
			&i.StartEpoch,
			&i.FastRetrieval,
			&i.ReceivedAt,
			&i.WonAt,
			&i.ProposalCid,
			&i.ProposalCidDeliveredAt,
			&i.ProposalCidDeliveryError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBidsWonAt = `-- name: UpdateBidsWonAt :many
UPDATE bids SET won_at = CURRENT_TIMESTAMP
WHERE id = ANY($1::text[]) AND auction_id = $2
RETURNING id
`

type UpdateBidsWonAtParams struct {
	BidIds    []string   `json:"bidIds"`
	AuctionID auction.ID `json:"auctionID"`
}

func (q *Queries) UpdateBidsWonAt(ctx context.Context, arg UpdateBidsWonAtParams) ([]auction.BidID, error) {
	rows, err := q.query(ctx, q.updateBidsWonAtStmt, updateBidsWonAt, pq.Array(arg.BidIds), arg.AuctionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []auction.BidID
	for rows.Next() {
		var id auction.BidID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProposalCid = `-- name: UpdateProposalCid :exec
UPDATE bids
SET proposal_cid = $3, proposal_cid_delivered_at = CURRENT_TIMESTAMP
WHERE id = $1 AND auction_id = $2
`

type UpdateProposalCidParams struct {
	ID          auction.BidID  `json:"id"`
	AuctionID   auction.ID     `json:"auctionID"`
	ProposalCid sql.NullString `json:"proposalCid"`
}

func (q *Queries) UpdateProposalCid(ctx context.Context, arg UpdateProposalCidParams) error {
	_, err := q.exec(ctx, q.updateProposalCidStmt, updateProposalCid, arg.ID, arg.AuctionID, arg.ProposalCid)
	return err
}

const updateProposalCidDeliveryError = `-- name: UpdateProposalCidDeliveryError :exec
UPDATE bids
SET proposal_cid_delivery_error = $3
WHERE id = $1 AND auction_id = $2
`

type UpdateProposalCidDeliveryErrorParams struct {
	ID                       auction.BidID  `json:"id"`
	AuctionID                auction.ID     `json:"auctionID"`
	ProposalCidDeliveryError sql.NullString `json:"proposalCidDeliveryError"`
}

func (q *Queries) UpdateProposalCidDeliveryError(ctx context.Context, arg UpdateProposalCidDeliveryErrorParams) error {
	_, err := q.exec(ctx, q.updateProposalCidDeliveryErrorStmt, updateProposalCidDeliveryError, arg.ID, arg.AuctionID, arg.ProposalCidDeliveryError)
	return err
}
